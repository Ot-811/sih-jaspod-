<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Assessment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .game-square {
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .game-square.active {
            background-color: #0ea5e9; /* sky-500 */
            transform: scale(1.05);
        }
        .star-point {
            position: absolute;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .target-shape {
            width: 80%;
            height: 80%;
            transition: opacity 0.2s;
            pointer-events: none; /* Clicks go to the parent square */
        }
        #wordList {
            height: 150px; /* Fixed height for the word list */
        }
        .builder-grid-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #cbd5e1; /* slate-300 */
        }
        .builder-grid-cell.filled {
            background-color: #3b82f6; /* blue-500 */
        }
        .memory-item {
            font-size: 4rem;
        }
        .recall-option {
            font-size: 2.5rem;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
        }
        .recall-option:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- Initial view: Centered Start Button -->
    <div id="initialView" class="flex flex-col items-center justify-center min-h-screen">
        <div id="resultsView" class="hidden text-center p-8">
            <h1 class="text-4xl font-bold text-slate-900 mb-4">Test Complete!</h1>
            <p class="text-lg text-slate-600 mb-8">Thank you for completing the assessment.</p>
        </div>
        <button id="startTestBtn" class="bg-sky-500 text-white font-bold px-12 py-6 rounded-full text-2xl hover:bg-sky-600 transition-transform duration-300 transform hover:scale-105 shadow-lg">
            Start Test
        </button>
    </div>

    <!-- Game view: Hidden by default -->
    <div id="gameView" class="hidden min-h-screen flex items-center justify-center">
        <div id="gameContainer" class="w-full max-w-md mx-auto p-8 text-center">
            <h1 id="gameTitle" class="text-3xl font-bold mb-2 text-slate-900"></h1>
            <p id="gameMessage" class="mb-6 text-slate-500"></p>
            
            <div id="gameArea" class="relative">
                <!-- Game elements will be generated by JS -->
            </div>
            
            <div class="mt-8">
                <p id="game-score-display" class="text-slate-500"></p>
                <button id="nextGameBtn" class="hidden mt-4 bg-green-500 text-white font-bold px-8 py-3 rounded-lg hover:bg-green-600 transition">Next Game</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- DOM Elements ---
            const startTestBtn = document.getElementById('startTestBtn');
            const initialView = document.getElementById('initialView');
            const resultsView = document.getElementById('resultsView');
            const gameView = document.getElementById('gameView');
            const gameContainer = document.getElementById('gameContainer');
            const gameTitle = document.getElementById('gameTitle');
            const gameMessage = document.getElementById('gameMessage');
            const gameArea = document.getElementById('gameArea');
            const gameScoreDisplay = document.getElementById('game-score-display');
            const nextGameBtn = document.getElementById('nextGameBtn');

            // --- Game Management ---
            const games = [
                { id: 'patternRecall', setup: setupPatternRecall, cleanup: cleanupPatternRecall, title: 'Pattern Recall', description: 'Watch the sequence carefully.' },
                { id: 'memoryStore', setup: setupMemoryStore, cleanup: cleanupMemory, title: 'Memory Store', description: 'Remember these 5 items.' },
                { id: 'starConnect', setup: setupStarConnect, cleanup: cleanupStarConnect, title: 'Star Connect', description: 'Connect in order: 1-A-2-B...' },
                { id: 'digitSpan', setup: setupDigitSpan, cleanup: cleanupDigitSpan, title: 'Digit Span', description: 'Repeat the numbers you see.' },
                { id: 'blockBuilder', setup: setupBlockBuilder, cleanup: cleanupBlockBuilder, title: 'Block Builder', description: 'Copy the pattern on the left.' },
                { id: 'targetTap', setup: setupTargetTap, cleanup: cleanupTargetTap, title: 'Target Tap', description: 'Tap the circles, ignore other shapes.' },
                { id: 'wordStorm', setup: setupWordStorm, cleanup: cleanupWordStorm, title: 'Word Storm', description: 'Type words starting with the given letter.' },
                { id: 'memoryRecall', setup: setupMemoryRecall, cleanup: cleanupMemory, title: 'Memory Recall', description: 'Select the 5 items you saw earlier.' },
                { id: 'clockMaster', setup: setupClockMaster, cleanup: cleanupClockMaster, title: 'Clock Master', description: 'Place the numbers and set the time.' }
            ];
            let currentGameIndex = 0;
            let state = 'IDLE';
            let sessionResults = {};

            // --- Game-specific State ---
            let patternRecallState = {};
            let starConnectState = {};
            let blockBuilderState = {};
            let targetTapState = {};
            let wordStormState = {};
            let memoryState = {};
            let digitSpanState = {};
            let clockMasterState = {};


            function startGame() {
                resultsView.classList.add('hidden');
                startTestBtn.textContent = 'Start Test';
                initialView.classList.add('hidden');
                gameView.classList.remove('hidden');
                currentGameIndex = 0;
                sessionResults = {};
                loadGame(games[currentGameIndex]);
            }

            function nextGame() {
                nextGameBtn.classList.add('hidden');
                games[currentGameIndex].cleanup();
                currentGameIndex++;
                if (currentGameIndex < games.length) {
                    loadGame(games[currentGameIndex]);
                } else {
                    showTestComplete();
                }
            }
            
            function showTestComplete() {
                console.log("Final Session Results:", JSON.stringify(sessionResults, null, 2));
                gameView.classList.add('hidden');
                initialView.classList.remove('hidden');
                resultsView.classList.remove('hidden');
                startTestBtn.textContent = 'Retake Test';
            }

            function loadGame(game) {
                gameTitle.textContent = game.title;
                gameMessage.textContent = game.description;
                gameScoreDisplay.textContent = '';
                game.setup();
            }

            // --- Pattern Recall Game ---
            function setupPatternRecall() {
                gameArea.innerHTML = ''; 
                gameArea.className = 'relative grid grid-cols-3 gap-4 w-64 h-64 mx-auto md:w-80 md:h-80';

                for (let i = 0; i < 9; i++) {
                    const square = document.createElement('div');
                    square.classList.add('game-square', 'bg-slate-200', 'rounded-lg', 'cursor-pointer');
                    square.dataset.index = i;
                    square.addEventListener('click', () => handlePatternRecallInput(i));
                    gameArea.appendChild(square);
                }

                patternRecallState = {
                    squares: Array.from(gameArea.children),
                    sequence: [],
                    playerSequence: [],
                    level: 3,
                    startTime: 0
                };
                
                runPatternRecallSequence();
            }

            function runPatternRecallSequence() {
                state = 'WATCHING';
                patternRecallState.playerSequence = [];
                gameMessage.textContent = 'Watch the sequence...';
                
                patternRecallState.sequence = [];
                for (let i = 0; i < patternRecallState.level; i++) {
                    patternRecallState.sequence.push(Math.floor(Math.random() * 9));
                }

                let i = 0;
                const interval = setInterval(() => {
                    if (i > 0) patternRecallState.squares[patternRecallState.sequence[i-1]].classList.remove('active');
                    if (i < patternRecallState.sequence.length) {
                        patternRecallState.squares[patternRecallState.sequence[i]].classList.add('active');
                    } else {
                        clearInterval(interval);
                        state = 'REPEATING';
                        patternRecallState.startTime = Date.now();
                        gameMessage.textContent = 'Now, repeat the sequence.';
                    }
                    i++;
                }, 800);
            }

            function handlePatternRecallInput(index) {
                if (state !== 'REPEATING') return;

                patternRecallState.playerSequence.push(index);
                patternRecallState.squares[index].classList.add('active');
                setTimeout(() => patternRecallState.squares[index].classList.remove('active'), 200);

                const currentStep = patternRecallState.playerSequence.length - 1;

                if (patternRecallState.playerSequence[currentStep] !== patternRecallState.sequence[currentStep]) {
                    state = 'GAMEOVER';
                    sessionResults.patternRecall = {
                        finalLevel: patternRecallState.level - 1,
                        reactionTime: Date.now() - patternRecallState.startTime
                    };
                    gameMessage.textContent = `Game Over! Final Level: ${patternRecallState.level - 1}.`;
                    nextGameBtn.classList.remove('hidden');
                    return;
                }

                if (patternRecallState.playerSequence.length === patternRecallState.sequence.length) {
                    patternRecallState.level++;
                    gameScoreDisplay.textContent = `Level ${patternRecallState.level - 1} cleared!`;
                    setTimeout(runPatternRecallSequence, 1500);
                }
            }
            
            function cleanupPatternRecall() {
                gameArea.innerHTML = '';
            }

            // --- Memory Store / Recall Game ---
            function setupMemoryStore() {
                const allItems = ['ðŸ”‘', 'ðŸ“š', 'ðŸ’¡', 'ðŸŽ', 'ðŸ ', 'ðŸš—', 'â°', 'ðŸŽ¸', 'âš½ï¸', 'ðŸ’»'];
                memoryState.itemsToRemember = allItems.sort(() => 0.5 - Math.random()).slice(0, 5);
                
                gameArea.innerHTML = '';
                gameArea.className = 'flex items-center justify-center w-full h-64';

                let i = 0;
                const showItem = () => {
                    if (i < memoryState.itemsToRemember.length) {
                        gameArea.innerHTML = `<div class="memory-item">${memoryState.itemsToRemember[i]}</div>`;
                        i++;
                        setTimeout(showItem, 1500);
                    } else {
                        gameArea.innerHTML = '';
                        gameMessage.textContent = "Let's continue...";
                        setTimeout(nextGame, 1000);
                    }
                };
                showItem();
            }
            
            function setupMemoryRecall() {
                gameArea.innerHTML = '';
                gameArea.className = 'grid grid-cols-4 gap-4 w-full';

                const distractors = ['â­', 'ðŸŒ™', 'â˜€ï¸', 'â˜ï¸', 'ðŸŒ'];
                const options = [...memoryState.itemsToRemember, ...distractors].sort(() => 0.5 - Math.random());
                memoryState.selectedItems = new Set();
                memoryState.startTime = Date.now();
                
                options.forEach(item => {
                    const optionEl = document.createElement('div');
                    optionEl.textContent = item;
                    optionEl.className = 'recall-option p-4 bg-slate-200 rounded-lg text-center';
                    optionEl.addEventListener('click', () => handleMemoryRecallInput(optionEl, item));
                    gameArea.appendChild(optionEl);
                });
            }

            function handleMemoryRecallInput(element, item) {
                if(state === 'GAMEOVER') return;

                if (memoryState.selectedItems.has(item)) {
                    memoryState.selectedItems.delete(item);
                    element.classList.remove('bg-sky-500', 'text-white');
                } else {
                    if (memoryState.selectedItems.size < 5) {
                        memoryState.selectedItems.add(item);
                        element.classList.add('bg-sky-500', 'text-white');
                    }
                }
                
                if (memoryState.selectedItems.size === 5) {
                    state = 'GAMEOVER';
                    let score = 0;
                    let falsePositives = 0;
                    memoryState.selectedItems.forEach(selected => {
                        if (memoryState.itemsToRemember.includes(selected)) {
                            score++;
                        } else {
                            falsePositives++;
                        }
                    });
                    
                    sessionResults.memoryRecall = {
                        score: score,
                        falsePositives: falsePositives,
                        timeToSelect: Date.now() - memoryState.startTime
                    };

                    gameMessage.textContent = `You correctly recalled ${score} out of 5 items.`;
                    nextGameBtn.classList.remove('hidden');
                }
            }

            function cleanupMemory() {
                gameArea.innerHTML = '';
            }

            // --- Star Connect Game ---
            function setupStarConnect() {
                gameArea.innerHTML = ''; 
                gameArea.className = 'relative w-64 h-64 mx-auto md:w-80 md:h-80 bg-slate-100 rounded-lg';
                
                const points = ['1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E'];
                starConnectState = {
                    points: [],
                    expectedSequence: points,
                    currentStep: 0,
                    startTime: Date.now(),
                    moveTimes: []
                };

                points.forEach((label) => {
                    const point = document.createElement('div');
                    point.textContent = label;
                    point.dataset.label = label;
                    
                    const size = 'w-12 h-12 md:w-14 md:h-14';
                    const color = isNaN(parseInt(label)) ? 'bg-teal-200 text-teal-800' : 'bg-amber-200 text-amber-800';
                    point.className = `star-point rounded-full cursor-pointer ${size} ${color}`;
                    
                    let top, left, placed = false;
                    while (!placed) {
                        top = Math.random() * (gameArea.clientHeight - 60);
                        left = Math.random() * (gameArea.clientWidth - 60);
                        let overlaps = starConnectState.points.some(p => {
                            const pTop = parseFloat(p.style.top);
                            const pLeft = parseFloat(p.style.left);
                            return Math.sqrt(Math.pow(pTop - top, 2) + Math.pow(pLeft - left, 2)) < 60;
                        });
                        if (!overlaps) placed = true;
                    }
                    
                    point.style.top = `${top}px`;
                    point.style.left = `${left}px`;
                    
                    point.addEventListener('click', () => handleStarConnectInput(point));
                    starConnectState.points.push(point);
                    gameArea.appendChild(point);
                });

                state = 'PLAYING';
            }

            function handleStarConnectInput(point) {
                 if (state !== 'PLAYING') return;

                const expectedLabel = starConnectState.expectedSequence[starConnectState.currentStep];
                
                if (point.dataset.label === expectedLabel) {
                    starConnectState.moveTimes.push(Date.now() - starConnectState.startTime);
                    starConnectState.startTime = Date.now(); // Reset for next move
                    point.style.backgroundColor = '#22c55e';
                    point.style.color = 'white';
                    point.style.transform = 'scale(1.1)';
                    starConnectState.currentStep++;
                    
                    if (starConnectState.currentStep === starConnectState.expectedSequence.length) {
                        state = 'GAMEOVER';
                        sessionResults.starConnect = {
                            completed: true,
                            totalTime: starConnectState.moveTimes.reduce((a, b) => a + b, 0),
                            averageMoveTime: starConnectState.moveTimes.reduce((a, b) => a + b, 0) / starConnectState.moveTimes.length
                        };
                        gameMessage.textContent = 'Congratulations! Sequence complete.';
                        nextGameBtn.classList.remove('hidden');
                    }
                } else {
                    point.style.backgroundColor = '#ef4444';
                    point.style.color = 'white';
                    state = 'GAMEOVER';
                     sessionResults.starConnect = {
                        completed: false,
                        failedAtStep: starConnectState.currentStep,
                        errorType: `Expected ${expectedLabel}, got ${point.dataset.label}`
                    };
                    gameMessage.textContent = 'Incorrect. Game Over.';
                    nextGameBtn.classList.remove('hidden');
                }
            }

            function cleanupStarConnect() {
                gameArea.innerHTML = '';
            }
            
            // --- Digit Span Game ---
            function setupDigitSpan() {
                gameArea.innerHTML = '';
                gameArea.className = 'flex flex-col items-center justify-center w-full h-64';

                digitSpanState = {
                    level: 3,
                    sequence: '',
                    mode: 'forward', // forward -> backward
                    forwardSpan: 0
                };

                runDigitSpan();
            }
            
            function runDigitSpan() {
                gameArea.innerHTML = `<div id="digitDisplay" class="text-5xl font-bold"></div>`;
                gameMessage.textContent = `Memorize the numbers (${digitSpanState.mode})...`;
                
                digitSpanState.sequence = '';
                for (let i = 0; i < digitSpanState.level; i++) {
                    digitSpanState.sequence += Math.floor(Math.random() * 10);
                }
                
                document.getElementById('digitDisplay').textContent = digitSpanState.sequence;

                setTimeout(() => {
                    gameArea.innerHTML = `
                        <form id="digitForm">
                           <input type="text" id="digitInput" pattern="[0-9]*" inputmode="numeric" class="w-full p-3 text-2xl text-center border-2 border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                        </form>
                    `;
                    gameMessage.textContent = `Type the numbers in ${digitSpanState.mode} order.`;
                    document.getElementById('digitInput').focus();
                    document.getElementById('digitForm').addEventListener('submit', handleDigitSpanInput);
                }, 2500);
            }

            function handleDigitSpanInput(event) {
                event.preventDefault();
                const input = document.getElementById('digitInput').value;
                const correctSequence = digitSpanState.mode === 'forward' ? digitSpanState.sequence : digitSpanState.sequence.split('').reverse().join('');

                if (input === correctSequence) {
                    digitSpanState.level++;
                    gameScoreDisplay.textContent = 'Correct! Next round.';
                    setTimeout(runDigitSpan, 1500);
                } else {
                    if (digitSpanState.mode === 'forward') {
                        digitSpanState.forwardSpan = digitSpanState.level - 1;
                        digitSpanState.mode = 'backward';
                        digitSpanState.level = 3; // Reset level for backward
                        gameScoreDisplay.textContent = 'Switching to backward recall.';
                        setTimeout(runDigitSpan, 1500);
                    } else {
                        sessionResults.digitSpan = {
                            forward: digitSpanState.forwardSpan,
                            backward: digitSpanState.level - 1
                        };
                        gameMessage.textContent = 'Test complete.';
                        nextGameBtn.classList.remove('hidden');
                    }
                }
            }

            function cleanupDigitSpan() {
                gameArea.innerHTML = '';
            }


            // --- Block Builder Game ---
            function setupBlockBuilder() {
                gameArea.innerHTML = '';
                gameArea.className = 'flex flex-col items-center justify-center w-full';

                blockBuilderState = {
                    targetPattern: [ [1, 1, 0], [0, 1, 0], [0, 1, 0] ],
                    userPattern: [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ],
                    correctionCount: 0,
                    startTime: Date.now()
                };
                
                gameArea.innerHTML = `
                    <div class="flex items-center justify-around w-full">
                        <div>
                            <p class="font-semibold mb-2">Target</p>
                            <div id="targetGrid" class="grid grid-cols-3 gap-1"></div>
                        </div>
                        <div>
                            <p class="font-semibold mb-2">Your Copy</p>
                            <div id="userGrid" class="grid grid-cols-3 gap-1"></div>
                        </div>
                    </div>
                    <button id="checkPatternBtn" class="mt-6 bg-sky-500 text-white font-bold px-8 py-3 rounded-lg hover:bg-sky-600 transition">Check Answer</button>
                `;

                const targetGrid = document.getElementById('targetGrid');
                const userGrid = document.getElementById('userGrid');

                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        const targetCell = document.createElement('div');
                        targetCell.className = 'builder-grid-cell';
                        if (blockBuilderState.targetPattern[r][c]) { targetCell.classList.add('filled'); }
                        targetGrid.appendChild(targetCell);

                        const userCell = document.createElement('div');
                        userCell.className = 'builder-grid-cell cursor-pointer';
                        userCell.dataset.row = r;
                        userCell.dataset.col = c;
                        userCell.addEventListener('click', handleBlockBuilderInput);
                        userGrid.appendChild(userCell);
                    }
                }

                document.getElementById('checkPatternBtn').addEventListener('click', checkBlockBuilderAnswer);
                state = 'PLAYING';
            }

            function handleBlockBuilderInput(event) {
                if (state !== 'PLAYING') return;
                const cell = event.target;
                const row = cell.dataset.row;
                const col = cell.dataset.col;

                if (blockBuilderState.userPattern[row][col] === 1) { blockBuilderState.correctionCount++; }

                blockBuilderState.userPattern[row][col] = 1 - blockBuilderState.userPattern[row][col];
                cell.classList.toggle('filled');
            }

            function checkBlockBuilderAnswer() {
                if (state !== 'PLAYING') return;
                state = 'GAMEOVER';

                const isCorrect = JSON.stringify(blockBuilderState.userPattern) === JSON.stringify(blockBuilderState.targetPattern);
                
                sessionResults.blockBuilder = {
                    isCorrect: isCorrect,
                    completionTime: Date.now() - blockBuilderState.startTime,
                    correctionCount: blockBuilderState.correctionCount
                };

                if (isCorrect) {
                    gameMessage.textContent = 'Perfect Match! Well done.';
                } else {
                    gameMessage.textContent = 'Not quite a match. Let\'s move on.';
                }
                document.getElementById('checkPatternBtn').disabled = true;
                nextGameBtn.classList.remove('hidden');
            }

            function cleanupBlockBuilder() {
                gameArea.innerHTML = '';
            }


            // --- Target Tap Game ---
            function setupTargetTap() {
                gameArea.innerHTML = '';
                gameArea.className = 'relative grid grid-cols-3 gap-4 w-64 h-64 mx-auto md:w-80 md:h-80';

                targetTapState = {
                    squares: [],
                    score: 0,
                    commissionErrors: 0,
                    omissionErrors: 0,
                    targetsShown: 0,
                    gameInterval: null,
                    gameDuration: 20000,
                };

                for (let i = 0; i < 9; i++) {
                    const square = document.createElement('div');
                    square.classList.add('game-square', 'bg-slate-200', 'rounded-lg', 'cursor-pointer');
                    square.dataset.index = i;
                    square.addEventListener('click', handleTargetTapInput);
                    gameArea.appendChild(square);
                    targetTapState.squares.push(square);
                }
                
                runTargetTapGame();
            }

            function runTargetTapGame() {
                state = 'PLAYING';
                const startTime = Date.now();

                targetTapState.gameInterval = setInterval(() => {
                    const elapsedTime = Date.now() - startTime;
                    if (elapsedTime >= targetTapState.gameDuration) {
                        state = 'GAMEOVER';
                        clearInterval(targetTapState.gameInterval);
                        
                        targetTapState.squares.forEach(sq => {
                             if(sq.dataset.type === 'target') { targetTapState.omissionErrors++; }
                        });

                        sessionResults.targetTap = {
                           score: targetTapState.score,
                           commissionErrors: targetTapState.commissionErrors,
                           omissionErrors: targetTapState.omissionErrors
                        };
                        gameMessage.textContent = `Game Over! Final Score: ${targetTapState.score}`;
                        nextGameBtn.classList.remove('hidden');
                        return;
                    }

                    targetTapState.squares.forEach(sq => {
                        if(sq.dataset.type === 'target') { targetTapState.omissionErrors++; }
                        sq.innerHTML = '';
                        delete sq.dataset.type;
                    });

                    const randomIndex = Math.floor(Math.random() * 9);
                    const square = targetTapState.squares[randomIndex];
                    const isTarget = Math.random() > 0.4;
                    
                    if (isTarget) {
                        const shape = document.createElement('div');
                        shape.className = 'target-shape bg-sky-500 rounded-full';
                        square.dataset.type = 'target';
                        square.appendChild(shape);
                        targetTapState.targetsShown++;
                    } else {
                        const distractors = ['square', 'triangle'];
                        const distractorType = distractors[Math.floor(Math.random() * distractors.length)];
                        square.dataset.type = 'distractor';
                        
                        const shape = document.createElement('div');
                        if (distractorType === 'square') {
                            shape.className = 'target-shape bg-pink-500';
                        } else {
                            shape.className = 'target-shape';
                            shape.style.backgroundColor = '#a855f7';
                            shape.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                        }
                        square.appendChild(shape);
                    }

                }, 1200);
            }
            
            function handleTargetTapInput(event) {
                if (state !== 'PLAYING') return;
                
                const square = event.currentTarget;
                if (!square.dataset.type) { return; }

                if (square.dataset.type === 'target') {
                    targetTapState.score++;
                } else {
                    targetTapState.score--;
                    targetTapState.commissionErrors++;
                }
                
                gameScoreDisplay.textContent = `Score: ${targetTapState.score}`;
                square.innerHTML = '';
                delete square.dataset.type;
                event.stopPropagation();
            }

            function cleanupTargetTap() {
                if (targetTapState.gameInterval) {
                    clearInterval(targetTapState.gameInterval);
                }
                gameArea.innerHTML = '';
            }

            // --- Word Storm Game ---
            function setupWordStorm() {
                gameArea.innerHTML = '';
                gameArea.className = 'flex flex-col items-center justify-start w-full h-full';

                const letters = ['F', 'A', 'S', 'T'];
                const letter = letters[Math.floor(Math.random() * letters.length)];

                wordStormState = {
                    letter: letter,
                    words: new Set(),
                    timer: 30,
                    gameInterval: null,
                    firstWordTime: 0
                };
                
                gameArea.innerHTML = `
                    <div class="text-6xl font-bold text-slate-800 mb-4">Letter: ${letter}</div>
                    <div id="wordStormTimer" class="text-2xl text-sky-600 font-semibold mb-4">Time Left: 30s</div>
                    <form id="wordForm" class="w-full">
                        <input type="text" id="wordInput" class="w-full p-3 border-2 border-slate-300 rounded-lg text-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500" placeholder="Type a word and press Enter">
                    </form>
                    <div id="wordList" class="w-full mt-4 p-2 bg-slate-100 rounded-lg overflow-y-auto text-left"></div>
                `;
                
                document.getElementById('wordForm').addEventListener('submit', handleWordStormInput);
                document.getElementById('wordInput').focus();

                runWordStormGame();
            }
            
            function runWordStormGame() {
                state = 'PLAYING';
                wordStormState.startTime = Date.now();
                wordStormState.gameInterval = setInterval(() => {
                    wordStormState.timer--;
                    document.getElementById('wordStormTimer').textContent = `Time Left: ${wordStormState.timer}s`;
                    if (wordStormState.timer <= 0) {
                        state = 'GAMEOVER';
                        clearInterval(wordStormState.gameInterval);
                        document.getElementById('wordInput').disabled = true;
                        
                        sessionResults.wordStorm = {
                            wordCount: wordStormState.words.size,
                            words: Array.from(wordStormState.words),
                            timeToFirstWord: wordStormState.firstWordTime
                        };
                        gameMessage.textContent = `Time's up! You found ${wordStormState.words.size} words.`;
                        nextGameBtn.classList.remove('hidden');
                    }
                }, 1000);
            }

            function handleWordStormInput(event) {
                event.preventDefault();
                if (state !== 'PLAYING') return;

                const input = document.getElementById('wordInput');
                const word = input.value.trim().toLowerCase();
                const list = document.getElementById('wordList');

                if (word.length > 1 && word.startsWith(wordStormState.letter.toLowerCase()) && !wordStormState.words.has(word)) {
                    if (wordStormState.words.size === 0) {
                        wordStormState.firstWordTime = Date.now() - wordStormState.startTime;
                    }
                    wordStormState.words.add(word);
                    const wordEl = document.createElement('div');
                    wordEl.textContent = word;
                    wordEl.className = 'p-1 bg-green-100 rounded-md mb-1 text-green-800';
                    list.appendChild(wordEl);
                    list.scrollTop = list.scrollHeight;
                    gameScoreDisplay.textContent = `Words Found: ${wordStormState.words.size}`;
                }
                input.value = '';
            }

            function cleanupWordStorm() {
                if (wordStormState.gameInterval) {
                    clearInterval(wordStormState.gameInterval);
                }
                gameArea.innerHTML = '';
            }

            // --- Clock Master Game ---
            function setupClockMaster() {
                gameArea.innerHTML = '';
                gameArea.className = 'flex flex-col items-center justify-center w-full';
                gameMessage.textContent = 'Drag the numbers to their correct positions on the clock.';

                clockMasterState = {
                    stage: 'placing_numbers',
                    placedNumbers: 0,
                    startTime: Date.now()
                };

                gameArea.innerHTML = `
                    <div id="clockFace" class="relative w-64 h-64 md:w-80 md:h-80 bg-white border-8 border-slate-300 rounded-full"></div>
                    <div id="numberBank" class="flex flex-wrap justify-center gap-2 mt-4"></div>
                `;

                const numbers = [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
                const numberBank = document.getElementById('numberBank');
                numbers.forEach(n => {
                    const numEl = document.createElement('div');
                    numEl.textContent = n;
                    numEl.id = `num-${n}`;
                    numEl.className = 'w-10 h-10 flex items-center justify-center bg-amber-200 rounded-full font-bold cursor-grab';
                    numEl.draggable = true;
                    numEl.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', n));
                    numberBank.appendChild(numEl);
                });

                const clockFace = document.getElementById('clockFace');
                clockFace.addEventListener('dragover', (e) => e.preventDefault());
                clockFace.addEventListener('drop', handleClockDrop);
            }
            
            function handleClockDrop(event) {
                event.preventDefault();
                if (clockMasterState.stage !== 'placing_numbers') return;
                
                const number = event.dataTransfer.getData('text/plain');
                const numEl = document.getElementById(`num-${number}`);
                const clockFace = document.getElementById('clockFace');
                
                const rect = clockFace.getBoundingClientRect();
                const x = event.clientX - rect.left - (numEl.offsetWidth / 2);
                const y = event.clientY - rect.top - (numEl.offsetHeight / 2);
                
                numEl.style.position = 'absolute';
                numEl.style.left = `${x}px`;
                numEl.style.top = `${y}px`;
                numEl.draggable = false;
                clockFace.appendChild(numEl);
                
                clockMasterState.placedNumbers++;
                if (clockMasterState.placedNumbers === 12) {
                    clockMasterState.stage = 'setting_hands';
                    document.getElementById('numberBank').innerHTML = '';
                    gameMessage.textContent = 'Now, click to set the hands to 10 past 11.';
                    clockFace.addEventListener('click', handleSetHands);
                }
            }
            
            function handleSetHands(event) {
                if (clockMasterState.stage !== 'setting_hands') return;

                const clockFace = document.getElementById('clockFace');
                // For simplicity, we just draw the hands. Scoring would involve checking click position.
                clockFace.innerHTML += `
                    <div style="position: absolute; top: 50%; left: 50%; width: 4px; height: 60px; background: black; transform-origin: top; transform: translate(-50%) rotate(335deg);"></div>
                    <div style="position: absolute; top: 50%; left: 50%; width: 4px; height: 80px; background: black; transform-origin: top; transform: translate(-50%) rotate(60deg);"></div>
                    <div style="position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; background: black; border-radius: 50%; transform: translate(-50%, -50%);"></div>
                `;

                sessionResults.clockMaster = {
                    numberPlacementTime: Date.now() - clockMasterState.startTime
                };
                gameMessage.textContent = 'Clock test complete!';
                nextGameBtn.classList.remove('hidden');
                clockFace.removeEventListener('click', handleSetHands);
            }

            function cleanupClockMaster() {
                gameArea.innerHTML = '';
            }

            // --- Initial Setup ---
            startTestBtn.addEventListener('click', startGame);
            nextGameBtn.addEventListener('click', nextGame);
        });
    </script>
</body>
</html>

